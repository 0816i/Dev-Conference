# 델타인코딩을 통한 업로드 향상

## 드라이브 서비스

온라인 파일공유, SAMBA지원, 팀원과 파일 공유, 프로젝트별 드라이브 관리 기능을 제공하고 있다. 파일당 최대 10기가까지 지원한다.

## 동기화 동작

드라이브 PC 동기화 앱을 설치하면 컴퓨터에 추가된 파일을 감지하고 서버에 전달한다. 그리고 이를 다른 사용자들이 다운받아 사용할 수 있다. 또한, 두레이에 올라온 파일도 로컬로 동기화할 수 있다. 파일이 변경된 경우 이를 서버로 전달한다. 이 전달된 부분만 전달하여 드라이브를 빠르게 이용하는 방법에 대해 다룬다.

## 델타 인코딩

데이터의 변경된 부분만 전달하는 방식이다.

**델타인코딩의 방식**

1. 파일 비교

   파일을 **블럭**으로 나누고 **checksum**을 계산해 비교하는 방식을 사용한다.

   **시그니처의 구성**

   - RSYNC (weak hash(계산비용과 공간이 작음), strong hash)
   - DROPBOX (strong hash)

   다만, 단순히 블럭을 나누어 비교하게 되면, offset이 변하는 경우 전체가 다르다는 판단을 내릴 수 있다. 따라서, rolling hash 를 사용하게 된다. 모든 블럭을 재계산하는 오버헤드가 발생하여, weak-hash를 통해 해시 일부를 캐싱할 수 있다. rolling hash 전략은 block단위로 비교하다가 해시가 달라지는 경우에만 동작하도록 한다. 만약 두 블럭의 해시가 동일하다면 블럭단위로 건너 뛴다.

   diff 결과 offset과 length를 포함한 reference와 실제 변경된 data를 포함한다.

2. Apply

   reference 필드의 경우 기존 파일에서 offset과 size만큼을 참조하고, data 필드의 경우 data값을 추가해 준다.

### 동기화 업/다운로드에서의 적용

**클라이언트→서버**

1. 주기적으로 파일 변경 감지
2. 서버로 signature 요청 후 전달받음
3. diff를 하고 instruction을 서버로 전달.
4. 서버는 instruction을 적용함.

서버→클라이언트

1. 주기적으로 서버파일 업데이트 감지 (클라이언트)
2. 서버로 파일 시그니처 전달
3. diff를 하고 instruction을 클라이언트로 전달
4. 전달받은 instruction을 파일에 적용해 최신 파일로 update

## 고민과 이슈들

### 성능이슈

클라이언트 → 서버 업데이트 구간의 성능저하 구간이 존재했다. 서버에서 시그니처를 생성할 때 느려서 해시를 캐싱하도록 수정했다. 특히 업로드를 할때 캐싱을 한다면 다음 업데이트시 빠르게 대응할 수 있다.

### instruction 응답

diff → instruction 응답시 성능저하 구간이 존재한다. 최초 업로드 instruction을 전달하고 이를 캐싱하면서 속도 문제를 해결할 수 있었다.

### 정말로 좋아졌을까

- 성능 vs 추가계산&공간: upload 시간에 비해 연산시간이 그리 길지는 않아서 무시할 만 했다.
  시그니처 크기의 경우 파일 크기에 따라 Block크기를 유동적으로 설정했다.

### 동기화 앱 이외의 용례

## Q&A

1. 여러 사용자의 동기화 문제에 문제가 없었나요? (collision control 이슈)
   - 동시 업로드가 발생해도 먼저 도착하는 요청이 먼저 될거고 나중에 올라오는거는 복사본으로 저장할 예정이다.
